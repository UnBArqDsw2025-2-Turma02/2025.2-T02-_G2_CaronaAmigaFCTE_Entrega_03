# 3.3. Módulo Padrões de Projeto GoFs Comportamentais

## Introdução 

Os padrões comportamentais descrevem como objetos interagem e distribuem responsabilidades, focando na comunicação entre eles sem aumentar o acoplamento (Gamma et al., 1995).

#### Por que são importantes
- Promovem a **flexibilidade na comunicação** entre objetos.  
- **Reduzem dependências diretas**, facilitando mudanças e expansões.  
- **Organizam o fluxo de controle** e o comportamento coletivo dos objetos.  
- Favorecem a **extensão de funcionalidades** sem modificar classes existentes.  

#### Exemplos comuns
- Chain of Responsibility  
- Command  
- Interpreter  
- Iterator  
- Mediator  
- Memento  
- Observer  
- State  
- Strategy  
- Template Method  
- Visitor  

Este capítulo foca em três padrões essenciais: **Mediator**, **Observer** e **Template Method**.  

---
## Metodologia
A equipe foi dividida em três grupos para aprofundar o estudo e a documentação dos padrões criacionais mais relevantes identificados, seguindo uma divisão similar à utilizada para as modelagens. A responsabilidade pela documentação detalhada de cada padrão foi distribuída conforme a tabela abaixo:

| Grupo     | Responsabilidade                                                                                                 | Integrantes                                                                                            |
| :-------- | :--------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------- |
| **Grupo 1** | Pesquisar e documentar o padrão **Template Method**, detalhando seus componentes, benefícios e desvantagens.  | Kaleb Macedo, Lucas Monteiro Freitas e Othavio Bolzan.                                                  |
| **Grupo 2** | Pesquisar e documentar o padrão **Observer**, explicando sua intenção, estrutura e aplicabilidade.               | Amanda Cruz, Arthur Sousa e Cauã Araujo.                                                               |
| **Grupo 3** | Detalhar e documentar a aplicação do **Mediator**, detalhando seus componentes, benefícios e desvantagens.          | Caio Venâncio, Caio Melo, Maria Eduarda e Pedro Henrique.                                              |

<p align="center"><b></b> Divisão das Equipes para Documentação dos Padrões Comportamentais</p>

Esta divisão permitiu que cada subgrupo se concentrasse num padrão específico, garantindo uma cobertura detalhada dos três GoFs criacionais selecionados. Enquanto o Grupo 3 focava na implementação prática e validação do Mediator (compilando o código e gerando o artefacto `.jar`), os Grupos 1 e 2 focavam na pesquisa teórica e de implementação na descrição dos padrões Template Method e Observer, respectivamente. Todo o material produzido foi posteriormente consolidado neste documento, assegurando uma apresentação coesa e completa dos padrões criacionais estudados.



---

### Mediator  

#### O que é  
O padrão **Mediator** define um objeto que encapsula a forma como um conjunto de objetos interage. Em vez de os objetos se comunicarem diretamente, eles se comunicam por meio de um mediador, que centraliza e gerencia a colaboração.  

#### Como se organiza  
- **Mediator**: define a interface para comunicação entre colegas.  
- **ConcreteMediator**: implementa a lógica de coordenação entre os objetos.  
- **Colleague**: classes que se comunicam apenas através do mediador.  

#### Quando usar  
- Quando há **muitas interdependências** entre objetos que dificultam manutenção.  
- Para **centralizar regras de interação** em um único ponto.  
- Quando se deseja **reduzir o acoplamento** e tornar o sistema mais modular.  

#### Exemplo prático  
Um chat em grupo onde o **servidor (Mediator)** gerencia todas as mensagens entre usuários (**Colleagues**).  

#### Vantagens  
- Reduz acoplamento entre componentes.  
- Centraliza a lógica de interação.  
- Facilita manutenção e reuso dos objetos.  

#### Riscos  
- Pode concentrar lógica demais no mediador, tornando-o complexo.  

---

### Observer  

#### O que é  
O **Observer** define uma dependência um-para-muitos entre objetos, de modo que quando um objeto muda de estado, todos os seus dependentes são notificados e atualizados automaticamente.  

#### Estrutura típica  
- **Subject**: mantém a lista de observadores e notifica mudanças.  
- **Observer**: define a interface de atualização.  
- **ConcreteSubject / ConcreteObserver**: implementações específicas que interagem.  

#### Quando usar  
- Quando uma mudança em um objeto deve **disparar atualizações automáticas** em outros.  
- Em sistemas **reativos** ou com **atualizações em tempo real** (interfaces, dashboards, etc.).  

#### Exemplo prático  
Um aplicativo de clima onde vários displays (**Observers**) atualizam automaticamente quando o serviço meteorológico (**Subject**) recebe novos dados.  

#### Vantagens  
- Promove baixo acoplamento entre objetos.  
- Facilita a adição de novos observadores sem alterar o código existente.  
- Ideal para aplicações orientadas a eventos.  

#### Desvantagens  
- Pode gerar notificações em excesso se não houver controle adequado.  

---

### Template Method  

#### O que é  
O **Template Method** define o esqueleto de um algoritmo em uma operação, permitindo que subclasses redefinam certas etapas sem alterar a estrutura geral do processo.  

#### Como se organiza  
- **AbstractClass**: define o template (sequência fixa de passos).  
- **ConcreteClass**: implementa os passos variáveis do algoritmo.  

#### Quando usar  
- Quando algoritmos possuem **etapas fixas e variáveis**.  
- Para **evitar duplicação de código** em classes que compartilham lógica geral.  
- Quando se deseja **padronizar processos**, mantendo flexibilidade em detalhes específicos.  

#### Exemplo prático  
Um sistema de geração de relatórios em que a sequência (abrir arquivo, coletar dados, formatar e salvar) é fixa, mas cada tipo de relatório implementa seu próprio formato.  

#### Vantagens  
- Reúso de código e padronização de processos.  
- Facilita extensões sem alterar a lógica principal.  

#### Desvantagens  
- Aumenta o acoplamento entre classes base e subclasses.  

---

### Comparação resumida

| Padrão | Uso principal | Elementos-chave |
|--------|----------------|----------------|
| **Mediator** | Centralizar e controlar a comunicação entre objetos | Mediator, Colleague |
| **Observer** | Notificar automaticamente dependentes sobre mudanças de estado | Subject, Observer |
| **Template Method** | Definir o esqueleto de um algoritmo e permitir variação em etapas específicas | AbstractClass, ConcreteClass |

---

### Conclusão  
Os padrões comportamentais são fundamentais para coordenar a comunicação e o comportamento entre objetos em sistemas orientados a objetos. O **Mediator** reduz dependências diretas ao centralizar interações, o **Observer** automatiza a propagação de mudanças e o **Template Method** padroniza algoritmos mantendo flexibilidade. Dominar esses padrões ajuda a criar sistemas mais organizados, extensíveis e de fácil manutenção.  

---

**Referências**  
> GAMMA, E.; HELM, R.; JOHNSON, R.; VLISSIDES, J. *Design Patterns: Elements of Reusable Object-Oriented Software.* Addison-Wesley, 1995.

---

| Versão | Data       | Descrição                                                                                             | Autor                                          | Revisor |
| :----: | ---------- | ----------------------------------------------------------------------------------------------------- | ---------------------------------------------- | ------- |
|  `1.0` | 22/10/2025 | Criação da descrição de GOFs Comportamentais. |  [Maria Eduarda](https://github.com/pyramidsf), [Caio Venâncio](https://github.com/caio-venancio), [Pedro Henrique](https://github.com/pedro-hsf), [Caio Melo](https://github.com/CaioMelo25)  |  |
|  `1.1` | 23/10/2025 | Adição de pequenos ajustes ao texto. |  [Maria Eduarda](https://github.com/pyramidsf)  |  |
