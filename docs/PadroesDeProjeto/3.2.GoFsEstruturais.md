# 3.2. Módulo Padrões de Projeto GoFs Estruturais

<!-- Foco_2: Padrões de Projeto GoFs Estruturais.

Entrega Mínima: 1 Padrão GoF Estrutural, com nível de modelagem e nível de implementação evidenciados (ou seja, código rodando e hospedado no repositório do projeto).

Apresentação (para a professora via vídeo enviado por e-mail) explicando o GoF Estrutural, com: (i) rastro claro aos membros participantes (MOSTRAR QUADRO DE PARTICIPAÇÕES & COMMITS); (ii) justificativas & senso crítico sobre o padrão GOF estrutural; e (iii) comentários gerais sobre o trabalho em equipe. Tempo da Apresentação: +/- 5min. Recomendação: Apresentar diretamente via Wiki ou GitPages do Projeto. Baixar os conteúdos com antecedência, evitando problemas de internet no momento de exposição via Vídeo nas Dinâmicas de Avaliação. Deve ser mostrado o GoF Estrutural em execução no vídeo.

A Wiki ou GitPages do Projeto deve conter um tópico dedicado ao Módulo Padrões de Projeto GoFs Estruturais, com 1 padrão GoF Estrutural (modelagem & implementação, com código rodando), histórico de versões, referências, e demais detalhamentos gerados pela equipe nesse escopo.

Demais orientações disponíveis nas Diretrizes (vide Moodle). -->

Os padrões estruturais descrevem maneiras de organizar classes e objetos para formar estruturas mais complexas, preservando flexibilidade e eficiência (Gamma et al., 1995).

## Por que são importantes

- Diminuem o acoplamento entre componentes.
- Favorecem a reutilização e a manutenção.
- Ajudam a estruturar internamente sistemas orientados a objetos.

### Exemplos comuns

- ***Adapter*** 
- ***Bridge***
- ***Composite***
- ***Decorator***
- ***Facade***
- ***Flyweight***
- ***Proxy***

Este capítulo foca em dois padrões fundamentais: [Adapter](/PadroesDeProjeto/Estrutural/adapter.md) ,**[Facade](/PadroesDeProjeto/Estrutural/facade.md)**, **[Proxy](/PadroesDeProjeto/Estrutural/proxy.md)**.

## Adapter

### O que é

Adapter (ou Wrapper) converte a interface de uma classe existente (Adaptee) para outra interface esperada pelo cliente (Target). O objetivo é permitir que classes com interfaces incompatíveis trabalhem juntas sem modificar o código existente.

### Como se organiza

- Target: interface esperada pelo cliente.
- Adaptee: classe existente com interface incompatível.
- Adapter: implementa/expõe a interface Target e delega (ou converte) chamadas para o Adaptee.
- Client: usa a interface Target.

### Quando usar

- Para integrar bibliotecas legadas cuja API não pode ser alterada.
- Quando precisamos reutilizar uma classe existente sem modificar sua implementação.

Esses adapters permitem que o cliente (por exemplo, uma classe de pagamento) invoque uma API uniforme (`Pagamento`) enquanto os Adaptees possuem APIs diferentes (PIX, Cartão). O adapter realiza as conversões e delegações necessárias. 

### Vantagens

- Permite reutilização de código legado sem modificá-lo.
- Separa responsabilidades de adaptação (SRP): a lógica de conversão fica no Adapter.

### Riscos / Considerações

- Pode introduzir camadas adicionais de delegação, aumentando ligeiramente a complexidade de rastreamento de chamadas.
- Verificar desempenho quando a adaptação envolve conversões pesadas.

## Facade

### O que é

Facade oferece uma interface única e simplificada para um conjunto de interfaces de um subsistema, tornando o uso desse subsistema mais direto e menos propenso a erros.

### Como se organiza

- Facade: ponto de entrada simples que delega operações ao subsistema.
- Subsystem Classes: implementam a lógica, acessadas indiretamente pela fachada.
- Client: usa a Facade em vez de interagir com várias classes do subsistema.

### Quando usar

- Quando se quer esconder a complexidade de um subsistema por trás de uma interface única.
- Para reduzir o acoplamento entre clientes e um conjunto de classes relacionadas.

Exemplo prático: uma biblioteca complexa (gráficos, BD, rede) que expõe uma API simplificada para desenvolvedores.

### Vantagens

- Simplifica a utilização do sistema.
- Reduz o acoplamento entre cliente e subsistema.
- Facilita evolução e manutenção.

### Riscos

- Se mal desenhada, pode virar um ponto central com responsabilidades demais.
- Pode ocultar funcionalidades importantes do subsistema.

## Proxy

### O que é

Proxy atua como representante de um objeto real, controlando o acesso a ele e podendo adicionar comportamentos como cache, controle de acesso ou inicialização tardia.

### Estrutura típica

- Subject: interface comum.
- RealSubject: objeto que faz o trabalho real.
- Proxy: intermediário que gerencia a interação com o RealSubject.

### Variantes comuns

- Virtual Proxy: cria o objeto real apenas quando necessário.
- Protection Proxy: valida permissões antes do acesso.
- Remote Proxy: representa objetos remotos.
- Cache Proxy: guarda resultados para evitar recomputação.

### Quando aplicar

- Para adicionar controle ou serviços extras sem modificar o objeto real.
- Para postergar criação de objetos pesados.
- Para representar objetos remotos em sistemas distribuídos.

Exemplo prático: um editor que usa proxy para carregar imagens grandes apenas quando exibidas.

### Vantagens

- Permite adicionar comportamentos (segurança, cache, lazy load) sem alterar o RealSubject.
- Pode reduzir custos de processamento e aumentar segurança.

### Desvantagens

- Introduz complexidade adicional.
- Pode degradar desempenho se mal implementado.

## Comparação resumida

| Padrão | Uso principal | Elementos-chave |
| ------ | ------------- | --------------- |
| **Facade** | Fornecer uma interface simplificada para um subsistema | Facade, Subsystem Classes, Client |
| **Proxy**  | Controlar e mediar o acesso a um objeto real | Proxy, RealSubject, Subject |
| **Adapter** | Compatibilizar interfaces incompatíveis / adaptar APIs | Adapter, Adaptee, Target, Client |

## Conclusão

Padrões estruturais são ferramentas valiosas para organizar a arquitetura interna de sistemas orientados a objetos. 
A Facade é indicada para simplificar interações com subsistemas complexos; o Proxy é adequado quando é preciso controlar, otimizar ou proteger o acesso a objetos; e o Adapter é a escolha correta quando precisamos compatibilizar interfaces incompatíveis sem alterar código legado. Dominar esses padrões contribui para sistemas mais modulares, claros e fáceis de manter.

## Referências 

> GAMMA, E.; HELM, R.; JOHNSON, R.; VLISSIDES, J. **Design Patterns: Elements of Reusable Object-Oriented Software**. Addison-Wesley, 1995.

> Refactoring.Guru: https://refactoring.guru/pt-br/design-patterns/

###  Histórico de Versões
| Versão | Data       | Descrição                             | Autor                                                 | Revisor                   |
| :----: | ---------- | ---------------------------           | ----------------------------------------------------- | --------------------------|
| `1.0`  | 16/10/2025 | Criação do documento                  |  [Arthur](https://github.com/Tutzs)                   |                           | 
| `1.1`  | 23/10/2025 | Adição do Adapter                     |  [Arthur](https://github.com/Tutzs)                   |                           |  