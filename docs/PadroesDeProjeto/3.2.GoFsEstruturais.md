# 3.2. Módulo Padrões de Projeto GoFs Estruturais

Os padrões estruturais descrevem maneiras de organizar classes e objetos para formar estruturas mais complexas, preservando flexibilidade e eficiência (Gamma et al., 1995).

## Metodologia

Para a seção de padrões estruturais desta entrega, a equipe organizou-se em três subgrupos com responsabilidades claras sobre os padrões selecionados. 

* Grupo 1 - **Documentação** do GoF Criacional.
* Grupo 2 - **Documentação** do GoF Estrutural.
* Grupo 3 - **Documentação** do GoF Comportamental.

O foco do nosso trabalho foi documentar tanto a modelagem quanto a implementação Java de cada padrão.

O Grupo 2 ficou responsável pela documentação detalhada e pela implementação do padrão **Facade** (modelagem, código e exemplos). Os demais grupos cobriram os padrões complementares do módulo estrutural:

| Grupo     | Responsabilidade                                                          | Integrantes                                            |
| :-------- | :---------------                                                          | :------------------------------------------------------|
| **Grupo 1** | Implementação do **Adapter** (modelagem + códigos Java).                | Kaleb Macedo, Lucas Monteiro Freitas e Othavio Bolzan.  |
| **Grupo 2** | Documentação no contexto geral e implementação do **Facade**. | Amanda Cruz, Arthur Sousa e Cauã Araujo. |
| **Grupo 3** | Implementação do **Proxy** (modelagem + códigos Java).                  | Caio Venâncio, Caio Melo, Maria Eduarda e Pedro Henrique. |

Cada grupo iniciou pela análise dos requisitos e diagramas arquiteturais para identificar os pontos onde o padrão em questão trazia maior valor. 

O Grupo 2 fez a análise e detectou cenários de orquestração (validação de motorista, criação de carona, criação de chat e notificações) que eram candidatos naturais para encapsulamento por uma fachada — daí a escolha das classes e serviços documentados e implementados em `implementação/Facade`.

O trabalho do Grupo 2 incluiu:

- Levantamento dos cenários de uso e mapeamento para diagramas (atividades, classes e pacotes).
- Projeto da interface de fachada e contratos públicos (assinaturas das operações de alto nível).
- Implementação de uma classe `CaronaFCTE_FacadeImpl` que orquestra `CaronaService`, `ChatService` e `NotificacaoService`.
- Exemplificação com um `Main` que demonstra o uso da fachada pelo cliente.
- Redação da documentação com diagramas, trechos de código e notas sobre trade-offs e alternativas.

Todo o material produzido pelos três grupos foi consolidado na wiki do projeto, garantindo que cada padrão estruturado contenha modelagem, implementação e exemplos de execução para demonstrar a aplicação prática no contexto do sistema.

## Por que são importantes

- Diminuem o acoplamento entre componentes.
- Favorecem a reutilização e a manutenção.
- Ajudam a estruturar internamente sistemas orientados a objetos.

### Exemplos comuns

- ***Adapter*** 
- ***Bridge***
- ***Composite***
- ***Decorator***
- ***Facade***
- ***Flyweight***
- ***Proxy***

Este capítulo foca em três padrões fundamentais: [Adapter](/PadroesDeProjeto/Estrutural/adapter.md) ,**[Facade](/PadroesDeProjeto/Estrutural/facade.md)**, **[Proxy](/PadroesDeProjeto/Estrutural/proxy.md)**.

## Adapter

### O que é

Adapter (ou Wrapper) converte a interface de uma classe existente (Adaptee) para outra interface esperada pelo cliente (Target). O objetivo é permitir que classes com interfaces incompatíveis trabalhem juntas sem modificar o código existente.

### Como se organiza

- Target: interface esperada pelo cliente.
- Adaptee: classe existente com interface incompatível.
- Adapter: implementa/expõe a interface Target e delega (ou converte) chamadas para o Adaptee.
- Client: usa a interface Target.

### Quando usar

- Para integrar bibliotecas legadas cuja API não pode ser alterada.
- Quando precisamos reutilizar uma classe existente sem modificar sua implementação.

Esses adapters permitem que o cliente (por exemplo, uma classe de pagamento) invoque uma API uniforme (`Pagamento`) enquanto os Adaptees possuem APIs diferentes (PIX, Cartão). O adapter realiza as conversões e delegações necessárias. 

### Vantagens

- Permite reutilização de código legado sem modificá-lo.
- Separa responsabilidades de adaptação (SRP): a lógica de conversão fica no Adapter.

### Desvantagens

- Pode introduzir camadas adicionais de delegação, aumentando ligeiramente a complexidade de rastreamento de chamadas.
- Verificar desempenho quando a adaptação envolve conversões pesadas.

## Facade

### O que é

Facade oferece uma interface única e simplificada para um conjunto de interfaces de um subsistema, tornando o uso desse subsistema mais direto e menos propenso a erros.

### Como se organiza

- Facade: ponto de entrada simples que delega operações ao subsistema.
- Subsystem Classes: implementam a lógica, acessadas indiretamente pela fachada.
- Client: usa a Facade em vez de interagir com várias classes do subsistema.

### Quando usar

- Quando se quer esconder a complexidade de um subsistema por trás de uma interface única.
- Para reduzir o acoplamento entre clientes e um conjunto de classes relacionadas.

Exemplo prático: uma biblioteca complexa (gráficos, BD, rede) que expõe uma API simplificada para desenvolvedores.

### Vantagens

- Simplifica a utilização do sistema.
- Reduz o acoplamento entre cliente e subsistema.
- Facilita evolução e manutenção.

### Riscos

- Se mal desenhada, pode virar um ponto central com responsabilidades demais.
- Pode ocultar funcionalidades importantes do subsistema.

## Proxy

### O que é

Proxy atua como representante de um objeto real, controlando o acesso a ele e podendo adicionar comportamentos como cache, controle de acesso ou inicialização tardia.

### Estrutura típica

- Subject: interface comum.
- RealSubject: objeto que faz o trabalho real.
- Proxy: intermediário que gerencia a interação com o RealSubject.

### Variantes comuns

- Virtual Proxy: cria o objeto real apenas quando necessário.
- Protection Proxy: valida permissões antes do acesso.
- Remote Proxy: representa objetos remotos.
- Cache Proxy: guarda resultados para evitar recomputação.

### Quando aplicar

- Para adicionar controle ou serviços extras sem modificar o objeto real.
- Para postergar criação de objetos pesados.
- Para representar objetos remotos em sistemas distribuídos.

Exemplo prático: um editor que usa proxy para carregar imagens grandes apenas quando exibidas.

### Vantagens

- Permite adicionar comportamentos (segurança, cache, lazy load) sem alterar o RealSubject.
- Pode reduzir custos de processamento e aumentar segurança.

### Desvantagens

- Introduz complexidade adicional.
- Pode degradar desempenho se mal implementado.

## Comparação resumida

| Padrão | Uso principal | Elementos-chave |
| ------ | ------------- | --------------- |
| **Facade** | Fornecer uma interface simplificada para um subsistema | Facade, Subsystem Classes, Client |
| **Proxy**  | Controlar e mediar o acesso a um objeto real | Proxy, RealSubject, Subject |
| **Adapter** | Compatibilizar interfaces incompatíveis / adaptar APIs | Adapter, Adaptee, Target, Client |

## Conclusão

Padrões estruturais são ferramentas valiosas para organizar a arquitetura interna de sistemas orientados a objetos. 
A Facade é indicada para simplificar interações com subsistemas complexos; o Proxy é adequado quando é preciso controlar, otimizar ou proteger o acesso a objetos; e o Adapter é a escolha correta quando precisamos compatibilizar interfaces incompatíveis sem alterar código legado. Dominar esses padrões contribui para sistemas mais modulares, claros e fáceis de manter.

## Referências 

> GAMMA, E.; HELM, R.; JOHNSON, R.; VLISSIDES, J. **Design Patterns: Elements of Reusable Object-Oriented Software**. Addison-Wesley, 1995.

> Refactoring.Guru: https://refactoring.guru/pt-br/design-patterns/

###  Histórico de Versões
| Versão | Data       | Descrição                             | Autor                                                 | Revisor                   |
| :----: | ---------- | ---------------------------           | ----------------------------------------------------- | --------------------------|
<<<<<<< HEAD
| `1.0`  | 16/10/2025 | Criação do documento                  |  [Arthur](https://github.com/Tutzs)                   | [Amanda Cruz](https://github.com/mandicrz) | 
| `1.1`  | 23/10/2025 | Adição do Adapter                     |  [Arthur](https://github.com/Tutzs), [Amanda Cruz](https://github.com/mandicrz)                   | [Cauã Araujo](https://github.com/caua08)  |  
| `1.1`  | 23/10/2025 | Reescrita da Metodologia                     |  [Arthur](https://github.com/Tutzs), [Cauã Araujo](https://github.com/caua08)  | [Amanda Cruz](https://github.com/mandicrz) |  
=======
| `1.0`  | 16/10/2025 | Criação do documento                  |  [Arthur](https://github.com/Tutzs)                   |                           | 
| `1.1`  | 23/10/2025 | Adição do Adapter                     |  [Arthur](https://github.com/Tutzs)                   |                           |  
>>>>>>> origin/grupo3
